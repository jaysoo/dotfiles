module CustomTestHelper #:nodoc:
  def build_user options
    options[:login] ||= 'jason'
    options[:email] ||= "#{options[:login].gsub(/ /, '_')}@tin.com"
    options[:role] ||= User::SUPER_USER
    options[:financial_access] = 'full' unless options.has_key?(:financial_access)
    options[:account] ||= Account.new(:name => "#{options[:login]} account")
    options[:site] = (options[:site] || options[:account].sites[0] || options[:account].sites.build(:name => "#{options[:login]} site"))
    Time.zone = options[:site].time_zone
    options[:password] ||= 'test'
    options[:password_confirmation] ||= options[:password]

    u = User.new options
  end

  def create_user options = {}
    User.make! options
  end

  def login
    login_default_user
  end

  def login_default_user
    user = default_user
    login_as user
    user
  end

  def login_as user
    activate_authlogic
    UserSession.create! user
    @logged_in_user = user
  end

  def no_access_page
    if @logged_in_user.present?
      @logged_in_user.customer? ? announcements_path : workflows_path
    else
      new_user_session_path
    end
  end

  def xhr_redirection_path
    url = if @logged_in_user.present?
      @logged_in_user.customer? ? '/announcements' : '/workflows'
    else
      '/user_session/new'
    end
    "window.location.href = \"#{url}\";"
  end

  def assert_variance(opts, &action)
    some, none = opts[:some], opts[:none]

    assert_difference(some, &action) if some
    assert_no_difference(none, &action) if none
  end

  # asserts that the expected time is within =/- threshold
  def assert_time_within(expected, actual, threshold = 3.second)
    assert actual, "#{actual} wasn't within #{threshold} of #{expected}"
    assert_equal true, expected < (actual + threshold), "#{actual} wasn't within #{threshold} of #{expected}"
    assert_equal true, expected > (actual - threshold), "#{actual} wasn't within #{threshold} of #{expected}"
  end

  def assert_empty(coll)
    assert coll.empty?, "Collection expected to be empty, found #{coll.inspect}"
  end

  def assert_not_empty(coll)
    assert_equal false, coll.empty?, "Collection expected to be not empty, but found to be empty"
  end

  def assert_contents(expected, coll)
    assert_equal Set.new(expected), Set.new(coll), "Expected #{expected.inspect} but was #{coll.inspect}"
  end

  def assert_subset_of(superset, subset)
    subset -= superset
    assert_equal 0, subset.size, "The following elements were expected but not found in the superset: #{subset.inspect}"
  end

  def assert_not_contains(collection, member)
    assert_equal false, collection.include?(member)
  end

  def assert_now( actual )
    assert_time_within Time.zone.now, actual
  end

  def assert_error_matching matcher, object
    assert object.has_errors?, "No errors to match"
    assert object.errors.full_messages.any? {|error_msg| error_msg.match(matcher)}, "#{object.errors.full_messages.inspect}\n  did not contain:\n'#{matcher}'"
  end

  def assert_no_errors object
    assert !object.has_errors?, object.errors.full_messages.join('\n')
  end

  def assert_xml_equal actual, expected, message = nil
    assert_equal convert_xml_into_array(actual), convert_xml_into_array(expected), "#{actual} != #{expected}, #{message}"
  end

  def assert_custom_output_default(name, message = nil)
    assert_match(  /custom_output_defaults\/wk\/#{name}\z/, @response.rendered[:template].to_s )
  end

  def assert_custom_output_prince_default(name, message = nil)
    assert_match(  /custom_output_defaults\/prince\/#{name}\z/, @response.rendered[:template].to_s )
  end

  def assert_prawn_output_default(name, message = nil)
    assert_match( /#{name}.pdf.prawn\z/, @response.rendered[:template].to_s )
  end

  #Executes block and collects GC statistics during the block execution.
  #Collected stats are printed to stdout (or to the file set in $RUBY_GC_DATA_FILE env var):
  # - allocated memory size (in KB) during block execution
  # - number of memory allocations during block execution
  # - number of GC collections during block execution
  # - time (in milliseconds ) spent in GC
  #
  #Description string appears in stdout before statistics
  #Options are
  # - :disable_gc => true    - disables GC during execution
  # - :show_gc_dump => true  - shows GC heap dump after statistics
  #
  # Taken from: http://blog.pluron.com/2008/02/memory-profilin.html
  def gc_statistics(description = "", options = {})
      #do nothing if we don't have patched Ruby GC
      yield and return unless GC.respond_to? :enable_stats

      GC.enable_stats || GC.clear_stats
      GC.disable if options[:disable_gc]

      yield

      stat_string = description + ": "
      stat_string += "allocated: #{GC.allocated_size/1024}K total in #{GC.num_allocations} allocations, "
      stat_string += "GC calls: #{GC.collections}, "
      stat_string += "GC time: #{GC.time / 1000} msec"

      GC.log stat_string
      GC.dump if options[:show_gc_dump]

      GC.enable if options[:disable_gc]
      GC.disable_stats
  end

private

  def convert_xml_into_array xml
    children = nokogiri_strict_parse(xml).root.element_children
    ordered_by_name = children.to_a.sort { |a, b| a.name <=> b.name }
    ordered_by_name.map{|e| [e.name, e.values]}
  end
end
