class Moves::PalletMoveCreator < ActiveRecord::BaseWithoutTable
  include Moves::MassCreateUtil
  column :from_pallet_number, :string
  column :location_name, :string
  belongs_to :move
  validates_presence_of :from_pallet_number, :move
  attr_reader :pallet_numbers, :first_sku

  MAX_ALLOWED_PALLET_MOVES = 10

  def create
    @pallet_numbers = nil
    self.valid?
    to_location = find_location
    return false if self.has_errors?

    if from_pallet_number.blank?
      self.errors.add(:from_pallet_number, s_('MOVES_ERROR_MSG|does not exist'))
      return false
    end

    if self.move.site.external_pallet_numbers == Site::ALPHANUMERIC
      @pallet_numbers = Utils::Parser.parse_alphanumeric_lists from_pallet_number.to_s
      error_message = s_("MOVES_ERROR_MSG|At least one Pallet number must be provided.")
    else
      @pallet_numbers = Utils::Parser.parse_numeric_ranges from_pallet_number.to_s
      error_message = s_("MOVES_ERROR_MSG|must be composed of only numbers, separated by commas and/or dashes e.g. 1, 2, 4-8, 10-15")
    end

    unless @pallet_numbers
      self.errors.add(:from_pallet_number, error_message)
      return false
    end

    if @pallet_numbers.size > MAX_ALLOWED_PALLET_MOVES
      self.errors.add(:from_pallet_number, s_("MOVES_ERROR_MSG|can only support a maximum of {{{max_number_of_allowed_pallets}}} pallets specified at one time.").i(:max_number_of_allowed_pallets => Moves::PalletMoveCreator::MAX_ALLOWED_PALLET_MOVES))
      return false
    end

    expected_pallet_moves = []
    @pallet_numbers.each do |pallet_number|
      pallet = self.move.site.pallets.find_by_number(pallet_number.to_s)
      if pallet.nil?
        self.errors.add(:from_pallet_number, s_("MOVES_ERROR_MSG|{{{pallet_num}}} does not exist").i(:pallet_num => pallet_number))
        return false
      end

      if pallet.wip?
        self.errors.add(:from_pallet_number, s_("MOVES_ERROR_MSG|'{{{pallet_num}}}' is a WIP pallet and can not be moved.").i(:pallet_num => pallet_number))
        return false
      end

      # Moved the find inventory call based on whether the expected pallet move already exists, if it doesn't we want to save
      # that extra find inventory and incorporate the empty check into whether or not any expected unit moves were created
      epm = self.move.expected_pallet_moves.detect {|epm| epm.pallet == pallet && epm.to_location == to_location}
      if epm
        results = InventoryAdjustment.find_inventory self.move.site, :pallet_number => pallet_number.to_s
        if results.empty?
          self.errors.add(:from_pallet_number, s_("MOVES_ERROR_MSG|'{{{pallet_num}}}' is empty").i(:pallet_num => pallet_number))
          return false
        end
      else
        epm = ExpectedPalletMove.new :pallet => pallet, :to_location => to_location, :move => self.move
        epm.build_expected_unit_moves

        return unless validate_pick_constraints epm

        if epm.expected_unit_moves.size == 0
          self.errors.add(:from_pallet_number, s_("MOVES_ERROR_MSG|'{{{pallet_num}}}' is empty").i(:pallet_num => pallet_number))
          return false
        end
      end
      expected_pallet_moves << epm
    end

    @first_sku = find_first_sku(expected_pallet_moves)
    self.move.move_pallets expected_pallet_moves
    return false unless self.errors.empty? && self.move.errors.empty?
    Jobs::JobLotExpiriesAdjuster.update(self.move.job)
    true
  end

  private

  def find_first_sku(expected_pallet_moves)
    expected_pallet_moves.first.expected_unit_moves.first.sku
  end

  def validate_pick_constraints expected_pallet_move
    expected_pallet_move.expected_unit_moves.each do |um|
    #   move.pick_constraint.validate(um)
    #   if um.has_errors?
    #     copy_errors_to_base_from um
    #     return false
    #   end
    # end
    true
  end

  def find_location
    find_location_by :location_, :name
  end
end
