module ReservationValidator
  extend self

  def validate_inventory_discrepancy(discrepancy, site)
    remove_adjustment = discrepancy.remove_adjustment
    remove_adjustment.set_each_quantity if remove_adjustment
    add_adjustment = discrepancy.add_adjustment
    add_adjustment.set_each_quantity  if add_adjustment

    errors = roll_up_and_validate_inventory([remove_adjustment, add_adjustment].compact, site,
                                                    InventoryDiscrepancyMessageBuilder)
    errors.first#should have at most 1 error
  end

  def validate_inventory_adjustment(inventory_adjustment, site, message_builder)
    errors = roll_up_and_validate_inventory([inventory_adjustment], site, message_builder)
    errors.first#should have at most 1 error
  end

  def validate_inventory_adjustments(inventory, site, message_builder)
    roll_up_and_validate_inventory(inventory, site, message_builder)
  end

  def validate_inventory_for_removal(inventory, site, message_builder)
    roll_up_and_validate_inventory(inventory, site, message_builder) do |inv|
      inv.each_quantity = inv.each_quantity * -1
    end
  end

  def validate_inventory(inventory, site, message_builder)
    return unless inventory.present?

    each_quantity = inventory.each_quantity
    p 'each_quantity'
    p 'each_quantity'
    p 'each_quantity'
    p 'each_quantity'
    p each_quantity

    return if each_quantity >= 0

    available = AvailableInventoryRepository.available_each_quantity(site, inventory)

    p 'available'
    p 'available'
    p 'available'
    p 'available'
    p available

    return if each_quantity.abs <= available

    reservations = ReservedInventoryLevelRepository.reservations_for_qualified_sku(inventory)

    return message_builder.reservation_violation_message(
      qualified_sku_being_changed: inventory,
      each_quantity_of_change: each_quantity,
      available_each_quantity: available,
      reservations_violated: reservations)
  end

  def roll_up_by_pickable_sku(inventory)
    good_inventory = inventory.select{ |i| i.status == InventoryStatus::GOOD }
    grouped_inventory = good_inventory.group_by{ |i| PickableSku.build(i) }

    result = []

    grouped_inventory.each do |pickable_sku, inventory_group|
      total_each_quantity = inventory_group.sum(&:each_quantity)
      inventory = inventory_group.first
      result << QualifiedEachQuantity.build_with_quantity(inventory, total_each_quantity)
    end

    result
  end

  private

  def roll_up_and_validate_inventory(inventory, site, message_builder, &block)
    errors = []
    rolled_up_inventory = roll_up_by_pickable_sku(inventory)

    rolled_up_inventory.each do |inv|
      yield(inv) if block_given?
      error = self.validate_inventory(inv, site, message_builder)
      errors << error if error.present?
    end

    errors
  end

end
