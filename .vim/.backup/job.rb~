class Job < ActiveRecord::Base
  include QcSheets::QcSheetCreator
  include Warnings
  include Reconciler::Job
  include Overproduce::Validations::Production
  include Jobs::ProductionStatus
  include Jobs::Efficiency
  include ScopedBySite
  include Formatters::DateTimeFormatter
  extend Formatters::DateTimeFormatter

  NEW_PALLET_STRATEGY = 'new pallets'
  EACH_SELECTED_PALLET_STRATEGY = 'each selected pallet'
  SELECTED_AND_NEW_PALLET_STRATEGY =  'selected and new pallets'
  PRODUCTION_STRATEGY_OPTIONS = [[ N_('JOB_SHOW_ADD_PRODUCTION|on new pallets'), NEW_PALLET_STRATEGY], [N_('JOB_SHOW_ADD_PRODUCTION|on each selected pallet'), EACH_SELECTED_PALLET_STRATEGY], [N_('JOB_SHOW_ADD_PRODUCTION|on selected and new pallets'), SELECTED_AND_NEW_PALLET_STRATEGY]]
  NULOGY_EPSILON = 0.00001 #This is the smallest quantity we distinguish in our decimal database columns

  #return values for accept_line_materials method
  NO_SKU_FOR_JOB = 0
  NOT_USING_JOB_WIP_PALLET = 1
  NO_SUBCOMPONENTS_FOUND = 2
  NO_INVENTORY_FOUND = 3
  ACCEPT_MATERIALS_SUCCESS = 4
  MOVE_ERROR_ON_MOVE = 5
  JOB_HAS_RECONCILED_SUBCOMPONENTS = 6

  EXPORT_TO_CSV_LIMIT = 1000

  belongs_to :project
  belongs_to :accepted_by, :class_name => "User", :foreign_key => "accepted_by_id"
  belongs_to :invoice_item
  belongs_to :line
  belongs_to :line_reconciliation
  belongs_to :job_reconciliation
  belongs_to :site
  belongs_to :wip_pallet, :class_name => "Pallet"
  has_many :pallets, :order => 'number::numeric desc'
  belongs_to :pick_plan, :class_name => "Wms::PickPlan"

  # need to qualify the id in the order by due to the TimeReport#total_personnel_count method
  has_many :time_reports, :order => 'ended_at DESC, started_at DESC, time_reports.id'
  has_many :breaks
  has_many :productions, :order => 'produced_at desc'
  has_many :subcomponent_consumptions
  has_many :rejected_items, :order => 'rejected_items.id'
  has_many :job_lot_expiries, :dependent => :destroy, :autosave => true
  has_many :qc_sheets, :order => "name, performed_at DESC"
  has_many :inbound_stock_transfer_orders

  validates_presence_of :project, :line, :scheduled_end_at, :scheduled_start_at, :site_id # TODO: Add some defaults!
  validates_numericality_of :units_expected, :less_than => 100000000000, :greater_than_or_equal_to => 0

  before_destroy :destroyable?
  before_validation :set_site_id, :on => :create
  validate :validate_job, :prevent_freezing
  validate :validate_do_not_reconcile, :on => :update
  validate :prevent_line_change, :on => :update
  before_create :create_wip_pallet, :seed_units_expected
  before_validation :set_do_not_reconcile, :on => :update


  has_many :edi_outbound947_production, :class_name => Api::Edi::Mcl::Conagra::Bpcs::EdiOutbound947Production.name, :foreign_key => :source_id

  def self.get site, id
    scoped_by(site).find(id)
  end

  def has_edi_outbound947_production?
    edi_outbound947_production.count > 0
  end

  # order of inclusion matters here because Quickbooks::QbJob overrides methods defined on Accounting::Integration
  include Accounting::Integration
  include Quickbooks::QbJob

  strip_attributes

  STARTED = 'started'
  STOPPED = 'stopped'
  PAUSED = 'paused'

  STATUS_MAPPINGS = {
    N_("JOB_STATUS|Started") => STARTED,
    N_("JOB_STATUS|Paused") => PAUSED,
    N_("JOB_STATUS|Stopped") => STOPPED
  }

  def started?
    self.status == STARTED
  end

  def start!
    self.update_attribute('status', STARTED)
  end

  def stopped?
    self.status == STOPPED
  end

  def stop!
    self.update_attribute('status', STOPPED)
  end

  def destroyable? options={}
    options[:show_errors] = options.has_key?(:show_errors) ? options[:show_errors] : true
    if self.wip_pallet and self.wip_pallet.has_inventory?
      self.errors.add(:base, s_("JOB_INDEX_DELETE_ERROR_MSG|Job cannot be deleted because there is inventory already associated with the Job.")) if options[:show_errors]
      return false
    end

    if !deletable?
      self.errors.add(:base, s_("JOB_INDEX_DELETE_ERROR_MSG|Job cannot be deleted because it has been worked on.")) if options[:show_errors]
      return false
    end

    if Move.not_closed.for_job(self).count > 0
      self.errors.add(:base, s_("JOB_INDEX_DELETE_ERROR_MSG|Job cannot be deleted because it has open moves.")) if options[:show_errors]
      return false
     end

    true
  end

  def deletable?
    self.productions.empty? &&
    self.time_reports.empty? &&
    self.breaks.empty? &&
    self.rejected_items.empty? &&
    self.qc_sheets.empty? &&
    !has_reconciliation?
  end

  def editable?
    !self.invoiced? and !self.frozen_for_accounting?
  end

  def prevent_line_change
    if self.line_id_changed?
      if !self.productions.empty? or has_reconciliation?
        self.errors.add(:line_id, s_("Line|cannot be changed because production or a line reconciliation already exists on the job."))
      end
      inv = CurrentInventoryLevel.find(:first, :conditions => {:site_id => self.site_id, :pallet_id => self.wip_pallet})
      if inv
        self.errors.add(:line_id, s_("Line|cannot be changed because inventory exists on the Job's WIP pallet."))
      end
    end
  end

  def validate_job
    errors.add "scheduled_end_at", s_("ScheduledEnd|cannot be before the scheduled start time.") if (scheduled_start_at && scheduled_end_at) && scheduled_start_at > scheduled_end_at
    errors.add "accepted_by", s_("LineLeader|cannot be set to an inactive user.") if self.accepted_by and self.accepted_by_id_changed? and self.accepted_by.inactive?
    errors.add "accepted_by", s_("LineLeader|cannot be set to the nulogy user.") if self.accepted_by and self.accepted_by.role == User::SUPER_USER
  end

  def set_site_id
    self.site_id ||= self.project.site_id if self.project
  end

  def create_wip_pallet
    self.wip_pallet = self.site.pallets.create!(:pallet_type => Pallet::JOB_WIP, :number => "-"+self.site.next_pallet_number)
    PalletAssigner.assign(self.project, self.wip_pallet)
  end

  def self.index site, params={}
    conditions = ["j.site_id = :site_id"]
    bindings = {:site_id => site.id}

    unless params[:scheduled_before_at].blank?
      conditions << "scheduled_start_at <= :scheduled_before_at"
      bindings[:scheduled_before_at] = parse_localized_time params[:scheduled_before_at]
    end

    unless params[:scheduled_after_at].blank?
      conditions << "scheduled_end_at >= :scheduled_after_at"
      bindings[:scheduled_after_at] = parse_localized_time params[:scheduled_after_at]
    end

    unless params[:project_code].blank?
      project = site.projects.find_by_code(params[:project_code])
      conditions << "project_id = :project_id"
      bindings[:project_id] = project ? project.id : -1
    end

    unless params[:item_code].blank?
      sku = site.account.skus.find_by_code(params[:item_code])
      conditions << "p.sku_id = :sku_id"
      bindings[:sku_id] = sku ? sku.id : -1
    end

    unless params[:line_name].blank?
      line = site.lines.find(:first, :conditions => {:'locations.name' => params[:line_name]}, :include => :location)
      conditions << "line_id = :line_id"
      bindings[:line_id] = line ? line.id : -1
    end

    unless params[:line_leader_id].blank? or params[:line_leader_id] == "all"
      if params[:line_leader_id] == "none"
        conditions << "accepted_by_id IS NULL"
      else
        conditions << "accepted_by_id = :accepted_by_id"
        bindings[:accepted_by_id] = params[:line_leader_id]
      end
    end

    unless params[:status].blank? or params[:status] == "all"
      conditions << "j.status = :status"
      bindings[:status] = params[:status]
    end

    unless params[:has_production].blank? or params[:has_production] == "all"
      joins =<<-J
        LEFT JOIN productions AS prod ON prod.job_id = j.id
      J
      having = " HAVING count(prod.id) > 0 " if params[:has_production] == "yes"
      having = " HAVING count(prod.id) = 0 " if params[:has_production] == "no"
    end

    query =<<-SQL
      SELECT
        j.id, j.scheduled_start_at, j.scheduled_end_at, j.project_id, j.line_id, j.accepted_by_id, j.status, j.units_expected, j.started_at, j.ended_at
      FROM jobs AS j
        LEFT JOIN projects AS p ON p.id = j.project_id
        #{joins}
      WHERE
        #{conditions.join(" AND ")}
      GROUP BY
        j.id, j.scheduled_start_at, j.scheduled_end_at, j.project_id, j.line_id, j.accepted_by_id, j.status, j.units_expected, j.started_at, j.ended_at
      #{having}
      ORDER BY
        j.scheduled_start_at DESC, j.id DESC
    SQL

    page = params[:page].blank? ? 1 : params[:page]
    params[:page] = page
    paginate_by_sql([query, bindings], :per_page => params[:per_page] || 30, :page => page)
  end

  def self.search site, page, query_string
    query_int = query_string.to_i

    Job.paginate( {
      :conditions => ["jobs.id = :num AND projects.site_id = :site", {:num => query_int, :site => site}],
      :page => page, :include => [:project => [:sku, :customer]], :per_page => 5, :order => 'jobs.id ASC' })
  end

  def self.paging page, options = {}
    page = page.blank? ? 1 : page
    options.reverse_merge!({
      :page => page,
      :per_page => 20})

    order("started_at DESC").order("scheduled_start_at DESC").order("id DESC").paginate(options)
  end

  def seed_units_expected
    calculate_units_expected if self.units_expected == 0
  end

  def on_break?
    active_breaks.length > 0
  end

  def active_breaks
    self.breaks.collect{ |b| b if b.overlaps(Time.zone.now) }.compact
  end

  def resume!
    active_breaks[0].end if on_break?
  end

  def enforce_top_up_rules options
    pallets = []

    if not options[:pallet_number].blank?
      pallets << site.pallets.find_by_number(options[:pallet_number])
    elsif not options[:pallet_ids].blank?
      options[:pallet_ids].split(",").each do |id|
        pallet = self.site.pallets.find_by_id(id)

        self.errors.add(:base, s_("JOB_SHOW_ADD_PRODUCTION_ERROR_MSG|Pallet id {{{p_id}}} does not exist").i(:p_id => id)) if pallet.nil?
        pallets << pallet
      end
    end

    pallets.compact!

    (pallets - self.eligible_top_up_pallets).each do |i|
      if i.job == self
        self.errors.add(:base, s_("JOB_SHOW_ADD_PRODUCTION_ERROR_MSG|Pallet \#{{{p_number}}} already has production.").i(:p_number => i.number))
      elsif i.job_id.nil? and !i.has_inventory? and i.shipped == false
        # Empty pallets with no job are unfortunately absent from the eligible top up pallets even though there's no workflow-related reason to be unavailable for production
        next
      else
        self.errors.add(:base, s_("JOB_SHOW_ADD_PRODUCTION_ERROR_MSG|Pallet \#{{{p_number}}} is not eligible for top up.").i(:p_number => i.number))
      end
    end
  end

  def handle_production_strategy_errors options
    pallet_number = options[:pallet_number]

    if options[:production_strategy] == EACH_SELECTED_PALLET_STRATEGY
      self.errors.add(:base, s_("JOB_SHOW_ADD_PRODUCTION_ERROR_MSG|Must specify a pallet number")) if pallet_number.blank? and options[:pallet_ids].blank?
      if !site.pallets.find_by_number(pallet_number)
        p = Pallet.new :site => site, :number => pallet_number
        unless p.valid?
          self.copy_errors_to_base_from p
        end
      end
      enforce_top_up_rules options
    end

    if options[:production_strategy] == SELECTED_AND_NEW_PALLET_STRATEGY
      enforce_top_up_rules options
    end

    if self.site.use_external_pallet_numbers? and options[:production_strategy] != EACH_SELECTED_PALLET_STRATEGY
      self.errors.add(:base, s_("JOB_SHOW_ADD_PRODUCTION_ERROR_MSG|Must specify a pallet number to produce on when site uses external pallet numbers"))
    end

    if options[:pallet_number]
      if self.line.wip_pallet.number == options[:pallet_number] || self.wip_pallet.number == options[:pallet_number]
        self.errors.add(:pallet_number, s_("Pallet Number|cannot refer to a wip pallet."))
      end
    end
  end

  def handle_no_labor_errors
    if self.site.no_labor_on_production == Site::ERROR_NO_LABOR_ON_PRODUCTION
      # We use now since all production's produced_at are initialized with the current time
      now = Time.zone.now
      if self.started_at.nil? or (!self.ended_at.nil? and self.ended_at < now) or self.started_at > now
        timestamp = format_datetime(now)
        self.errors.add :base, s_("JOB_SHOW_ADD_PRODUCTION_ERROR_MSG|Production cannot be entered at {{{time_stamp}}} because there are no time reports at this time. Check there is at least one time report at this time.").i(:time_stamp => timestamp)
        return
      end
    end
  end

  def add_production_with_substitutions quantity, units, consumption_plan=nil, lot_code=nil, expiry_date=nil, options={}
    return [] if self.project.sku.nil?

    options[:pallet_number].try(:strip!)
    lot_code.try(:strip!)
    expiry_date.try(:strip!)

    lot_code = predefined_lot_code(lot_code)
    expiry_date = predefined_expiry_date(expiry_date)

    errors.add :base, s_("JOB_SHOW_ADD_PRODUCTION_ERROR_MSG|You cannot enter production on this Job because one or more subcomponents have been Reconciled. Please see your system administrator if these changes must be made.") if has_reconciled_subcomponents?
    errors.add :base, s_('JOB_SHOW_ADD_PRODUCTION_ERROR_MSG|Please start this Job before entering a Production Record.') unless self.started?
    return [] if has_errors?

    consumption_plan ||= ConsumptionPlan.new
    consumption_plan.finished_good = sku

    quantity = Utils::I18n.to_d(quantity)

    handle_quantity_errors quantity, units, options

    handle_lot_expiry_errors lot_code, expiry_date

    consumption_plan.valid?

    self.errors.add :base, s_("JOB_SHOW_ADD_PRODUCTION_ERROR_MSG|There were errors in the consumption configuration. See below.") if consumption_plan.errors[:base].present?

    handle_production_strategy_errors options
    handle_no_labor_errors

    self.errors.add(:base, s_("JOB_SHOW_ADD_PRODUCTION_ERROR_MSG|Job has already been invoiced.  Production cannot be added.")) if self.invoiced?
    self.errors.add(:base, s_("JOB_SHOW_ADD_PRODUCTION_ERROR_MSG|Job has been frozen for accounting.  Production cannot be added.")) if self.frozen_for_accounting?
    validate_units_remaining(units, quantity)

    ensure_destination_pallet_is_devoid_of_held_inventory! options

    return [] unless errors.empty?

    new_productions = []
    transaction do
      # to handle consumables
      moves = sku.all_consumable_moves_to_wip self.line, sku.convert(quantity, units, self.sku.unit_of_measure), consumption_plan, self
      insert_consumable_moves moves unless moves.empty?

      if options[:wip_warning] and self.project.site.inventory?
        self.warnings.clear
        unless sufficient_wip_quantity? quantity, units, consumption_plan
          raise ActiveRecord::Rollback
        end
      end

      begin
        new_productions = create_production units, quantity, lot_code, expiry_date, consumption_plan, options
        self.class.notify_observers(:add_production, new_productions)
      rescue ActiveRecord::StaleObjectError
        self.errors.add(:base, s_("JOB_SHOW_ADD_PRODUCTION_ERROR_MSG|An unexpected error occurred. Please retry the operation."))
        raise ActiveRecord::Rollback
      end
    end

    self.reload
    new_productions
  end

  def ensure_destination_pallet_is_devoid_of_held_inventory! options
    if !options[:pallet_number].blank?
      pallet = self.site.pallets.find_by_number(options[:pallet_number])
      return unless pallet
      options[:pallet_ids] = pallet.id.to_s
    end
    return unless options[:pallet_ids]

    held_inventory = HeldInventoryRepository.inventory_held_for_pallets options[:pallet_ids].split(",")
    if !held_inventory.empty?
      held_pallet_numbers = held_inventory.map(&:pallet).map(&:number)
      errors.add(:base, s_("JOB_SHOW_ADD_PRODUCTION_ERROR_MSG|Cannot produce onto pallet(s) {{{pallet_numbers}}} because they are held.").i( :pallet_numbers => held_pallet_numbers.join(", ")))
    end
  end

  # This method returns the new productions that are created.
  # lot_codes and expiry_date hashes should have the id of the sku that is the subcomponent as the key.
  def add_production(quantity, units, lot_code=nil, lot_codes={}, expiry_date=nil, expiry_dates={}, options={})
    consumption_plan = ConsumptionPlan.new_instance(sku, lot_codes, expiry_dates)
    add_production_with_substitutions quantity, units, consumption_plan, lot_code, expiry_date, options
  end

  def get_wip_pallet
    self.site.use_job_wip_pallet? ? self.wip_pallet : self.line.wip_pallet
  end

  def sufficient_wip_quantity_with_quick_consume? fg_quantity, unit_of_measure, consumption_plan
    return true if fg_quantity < 0

    result = false
    transaction do
      moves = sku.all_consumable_moves_to_wip(line, fg_quantity, consumption_plan, self)
      insert_consumable_moves moves unless moves.empty?
      result = sufficient_wip_quantity?(fg_quantity, unit_of_measure, consumption_plan)
      raise ActiveRecord::Rollback
    end
    result
  end

  # TODO: handle non-consumed and substitutes
  def sufficient_wip_quantity? fg_quantity, unit_of_measure, consumption_plan
     self.project.sku.bom_items(true).each do |bom_item|
       subcomponent = consumption_plan.subcomponent_to_consume(bom_item)
       next unless (subcomponent.auto_backflush and consumption_plan.is_consumed?(bom_item))
       lot_code = consumption_plan.lot_code(bom_item)
       expiry_date = consumption_plan.expiry_date(bom_item)
       required_qty = consumption_plan.quantity_to_consume(self.project.sku, bom_item) * self.project.sku.convert(fg_quantity, unit_of_measure)
       project_id = subcomponent.reserve_for_projects? ? self.project_id : nil
       wip_qty_in_eaches = query_wip_quantity(subcomponent, lot_code, expiry_date, project_id)
       project_code = subcomponent.reserve_for_projects? ? self.project.code : nil
       enough_quantity_in_wip?(subcomponent, lot_code, expiry_date, required_qty, wip_qty_in_eaches, subcomponent.unit_of_measure, project_code)
     end
     return self.warnings.empty?
  end

  def enough_quantity_in_wip? sku, lot_code, expiry_date, required_qty, wip_qty_in_eaches, unit_of_measure, project_code
     return true if required_qty <= 0
     return true if sku.track_lot_code_by == Sku::TRACK_BY_JOB && !self.site.include_track_by_job_subs_in_missing_inventory
     #return true if sku.quick_consume?
     required_qty_in_eaches = sku.convert_to_eaches(required_qty, unit_of_measure)
     return true if wip_qty_in_eaches >= required_qty_in_eaches

     if sku.track_lot_code_by == Sku::TRACK_BY_JOB
       lot_code = _("(All)")
       expiry_date = _("(All)")
     end

     warning = {
       sku_code: sku.code, lot_code: lot_code, expiry_date: expiry_date,
       required_qty: sku.convert(required_qty_in_eaches, "eaches"), wip_qty: sku.convert(wip_qty_in_eaches, "eaches"),
       project_code: project_code, unit_of_measure: sku.unit_of_measure}
     self.warnings.add(:base, WipMessage.hash_to_string(warning))
     false
  end

  # TODO: handle non-consumed and substitutes
  def create_production units, quantity, lot_code, expiry_date, consumption_plan, options
    quantity_in_eaches = self.sku.convert(quantity, units, :eaches)
    new_productions = []

    # this could be extended to support multiple pallet numbers but just do what's necessary for #2429 for now
    if !options[:pallet_number].blank?
      pallet = self.site.get_pallet options[:pallet_number]
      options[:pallet_ids] = pallet.id.to_s
    end

    sequence = ProductionPalletSequence.new(self, site.setting_production_pallet_sequencing)

    if !options[:pallet_ids].blank?
      pallet_ids = options[:pallet_ids].split(",")
      #check to see if the pallet exists in a different location
      results = CurrentInventoryLevel.pallets_not_in_location self.site, pallet_ids, self.line.location_id
      unless results.empty?
        results.each do |result|
          errors.add(:base, s_("JOB_SHOW_ADD_PRODUCTION_ERROR_MSG|Pallet \#{{{pallet_number}}} already exists in location '{{{location_name}}}'.").i(:pallet_number => result.pallet_number, :location_name => result.location_name))
        end
        return
      end
      #bulk insert of productions onto existing empty pallets, no limits on how much can be created on pallet
      if options[:production_strategy] == EACH_SELECTED_PALLET_STRATEGY
        pallet_ids.each do |id|
          pallet = self.site.pallets.find_by_id(id)
          if pallet
            pallet.job = self unless pallet.job_id
            pallet.sequence_number ||= sequence.next
            pallet.save!
            new_productions << pallet.create_production(self, quantity_in_eaches, consumption_plan, lot_code, expiry_date)
          end
        end
        quantity_in_eaches = 0 #we don't want to create any more new pallets
      elsif options[:production_strategy] == SELECTED_AND_NEW_PALLET_STRATEGY
        pallet_ids.each do |id|
          pallet = self.site.pallets.find_by_id(id)
          quantity_in_eaches -= top_up_pallet(pallet, quantity_in_eaches, lot_code, expiry_date, consumption_plan, new_productions)
        end
      end
    end

    new_pallets = []
    self.project.sku.each_pallet(quantity_in_eaches, :eaches) do |qty|
      pallet = Pallet.new :job => self, :site => self.project.site, :sequence_number => sequence.next
      new_pallets << pallet
      new_productions << pallet.create_production(self, qty, consumption_plan, lot_code, expiry_date)
    end

    insert_production new_pallets, new_productions
    new_productions
  end

  def insert_production new_pallets, new_productions
    new_subcomponent_consumptions = []
    new_inventory_adjustments = []
    new_productions.each do |p|
      p.subcomponent_consumptions.each {|sc| new_subcomponent_consumptions << sc}
      new_inventory_adjustments << p.inventory_adjustment if p.inventory_adjustment
    end

    new_subcomponent_consumptions.each do |sc|
      new_inventory_adjustments << sc.inventory_adjustment if sc.inventory_adjustment
    end

    transaction do
      Jobs::JobLotExpiries.add(self)

      Pallet.bulk_insert new_pallets

      new_inventory_adjustments.each do |ia|
        ia.pallet = ia.pallet
      end
      InventoryAdjustment.bulk_insert new_inventory_adjustments

      new_productions.each do |p|
        p.inventory_adjustment = p.inventory_adjustment
        p.pallet = p.pallet
      end
      Production.bulk_insert new_productions

      new_subcomponent_consumptions.each do |sc|
        sc.inventory_adjustment = sc.inventory_adjustment
        sc.production = sc.production
      end
      SubcomponentConsumption.bulk_insert new_subcomponent_consumptions
    end
  end

  def default_shift_length
    self.project.site.default_shift_length
  end

  # Use this method if you want to know the current total of units produced
  def cached_units_produced
    self.sku.convert(self.eaches_produced, Sku::EACHES)
  end

  #TODO: Change to return in the unit of measure of the scenario.
  # BEWARE:if changed to the unit of measure of the scenario, beware that some places rely on it being the unit of measure of the sku
  # ie. quickbook job integration
  # BEWARE: some callers rely on this being in eaches! (production_overview/_table.rhtml)
  # Note: This method caches the result
  # Currently returns in the unit of measure of the sku
  def units_produced(options={})
    if options.empty?
      @cached_units_produced ||= calculate_units_produced(options)
    else
      calculate_units_produced(options)
    end
  end

  def clear_units_produced_cache
    @cached_units_produced = nil
  end

  #returns in the unit of measure of the sku
  def uninvoiced_units_produced
    self.invoiced? ? 0 : self.units_produced
  end

  # How many units this job must produce. Important for request_subcomponents
  def units_required
    return units_expected if self.project.long_running?
    [units_expected, self.project.units_remaining].min
  end

  def units_remaining
    units_expected - units_produced
  end

  # Note this doesn't return a precentage but returns a fraction instead
  def percent_complete
    units_expected != 0 ?  units_produced / units_expected : 0.0
  end

  def units_expected_per_hour
    scheduled_duration == 0 ? 0 : units_expected / scheduled_duration
  end

  def units_produced_per_hour
    duration == 0 ? 0.0 : units_produced / duration
  end

  def production_reports
    pallets.collect { |p| p.productions }.flatten
  end

  def eligible_top_up_pallets
    sql =<<-SQL
      SELECT pallets.id, pallets.job_id, pallets.site_id, pallets.number,
        CASE WHEN SUM(pro.each_quantity) IS NULL THEN
          TRUE
        ELSE
          FALSE
        END AS empty

      FROM jobs
      LEFT JOIN pallets ON pallets.job_id = jobs.id
      LEFT JOIN productions AS pro ON pallets.id = pro.pallet_id
      LEFT JOIN projects ON projects.id = jobs.project_id
      LEFT JOIN lines ON lines.id = jobs.line_id
      LEFT JOIN pallet_shipments ON pallets.id = pallet_shipments.pallet_id
      WHERE
        pallets.shipped = FALSE
      AND
        projects.id = :project_id
      AND
        lines.id = :line_id
      AND
        pallet_shipments.id IS NULL

      GROUP BY pallets.id, pallets.job_id, pallets.site_id, pallets.number
      HAVING
        SUM(pro.each_quantity) < :eaches_per_pallet OR SUM(pro.each_quantity) IS NULL
    SQL

    eligible = []

    pallets = Pallet.find_by_sql([sql, {:project_id => self.project.id, :line_id => self.line.id, :eaches_per_pallet => self.sku.eaches_per_pallet}])

    eligible += pallets.select{|p| p.job_id == self.id and p.empty == "t"}

    if self.site.allow_top_up_from_current_job
      eligible += pallets.select{|p| p.job_id == self.id and p.empty == "f"}
    end

    if self.site.allow_top_up_from_previous_jobs
      eligible += pallets.select{|p| p.job_id != self.id and p.empty == "f"}
    end

    eligible.delete_if{|p| p.location and not p.in_location?(self.line.location)}
  end

  def self.find_between(from, to, site)
    Job.find_by_sql(self.query_between(from, to, site))
  end

  def self.query_between(from, to, site)
    [SQL_FOR_QUERY_BETWEEN, from.beginning_of_day, to.beginning_of_day + 1.day, site.id, site.id]
  end

  def self.find_uninvoiced( from, to, site, customer )
    sql = SQL_FOR_QUERY_BETWEEN + SQL_FOR_QUERY_BETWEEN_CUSTOMER + SQL_FOR_QUERY_BETWEEN_STOPPED
    sql = sql + SQL_FOR_QUERY_BETWEEN_NOT_POSTED unless site.account.allow_invoicing_posted_jobs?

    jobs = Job.find_by_sql([sql, from, to, site.id, site.id, customer.id])
    jobs.reject { |job| job.invoiced?  }
  end

  SQL_FOR_QUERY_BETWEEN =<<-SQL
    SELECT DISTINCT *
    FROM jobs
    WHERE id IN
      (SELECT job_id
      FROM time_reports
      WHERE time_reports.started_at IS NOT NULL
      AND time_reports.started_at >= ?
      AND time_reports.started_at <= ?
      AND site_id = ?)
    AND id NOT IN
      (SELECT job_id FROM time_reports
       WHERE time_reports.ended_at IS NULL AND site_id = ?)
    AND id NOT IN
      (SELECT job_id FROM breaks
       WHERE breaks.ended_at IS NULL)
  SQL

  SQL_FOR_QUERY_BETWEEN_CUSTOMER =<<-CLAUSE
    AND jobs.project_id IN
      (SELECT projects.id FROM projects
      WHERE projects.customer_id = ?)
  CLAUSE

  SQL_FOR_QUERY_BETWEEN_NOT_POSTED =<<-SQL
    AND jobs.synchronized_status != '#{Accounting::POSTED}'
  SQL

  SQL_FOR_QUERY_BETWEEN_STOPPED =<<-SQL
    AND jobs.status = 'stopped'
  SQL

  def production_start_at
    self.productions.minimum(:produced_at)
  end

  def production_end_at
    self.productions.maximum(:produced_at)
  end

  def calculate_ended_at
    return nil if time_reports.count(:conditions => {:ended_at => nil}) > 0
    time_reports.maximum(:ended_at)
  end

  #returns the duration in hours
  def duration(options={})
    return 0 if self.started_at.nil?
    interval_start = options[:start] ? [options[:start], self.started_at].max : self.started_at

    ending = self.ended_at || Time.zone.now
    interval_end = options[:end] ? [options[:end], ending].min : ending
    return 0 if interval_start > interval_end

    (interval_end - interval_start ) / 1.hour
  end

  #returns the scheduled duration in hours
  def scheduled_duration
    (scheduled_end_at - scheduled_start_at) / 1.hour
  end

  # Uses information from the Sku and the Job#scheduled_duration
  def calculate_units_expected
    self.units_expected = project.sku.units_per_hour * scheduled_duration if self.project.sku
  end

  # Determines the quantity you expect to produce based on the amount of people clocked in currently.
  def expected_instant_units_per_hour
    if project.sku
      number_of_clocked_in = self.time_reports.clocked_in.size
      ap = project.sku.assembly_procedure
      expected_personnel = project.sku.assembly_procedure.personnel
      unless expected_personnel && expected_personnel != 0
        project.sku.standard_units_per_hour
      else
        project.sku.standard_units_per_hour * (number_of_clocked_in / expected_personnel)
      end
    end
  end

  def self.job_schedule(user, from, to)
    jobs_sorted_by_date = user.site.jobs.find(
      :all,
      :conditions => [
        job_schedule_query_conditions(user),
        { :to => to, :from => from, :customer_id => user.customer_id}],
      :joins => "LEFT JOIN projects ON jobs.project_id = projects.id",
      :order => 'scheduled_start_at ASC')

    jobs_sorted_by_date.group_by {|job| job.line}
  end

  def expected_personnel
    project.sku ? project.sku.assembly_procedure.personnel : 0
  end

  # All subcomponents are requested in cases in this method because that is the most likely
  # unit for picking
  def request_subcomponents(user, site)
    unless sku
      self.errors.add :base, "This Job does not produce any finished good."
      return false
    end

    if sku.bom_items.empty?
      self.errors.add :base, "This finished good does not have any subcomponents."
      return false
    end

    bom_items = sku.bom_items.reject{|bom_item| bom_item.subcomponent.quick_consume?}
    if bom_items.empty?
      self.errors.add :base, "All subcomponents of #{sku.code} are configured as Quick Consume and therefore do not need to be Requested to this Job."
      return false
    end

    bom_items.each do |bom_item|
      candidate_bom_items = [bom_item] + bom_item.substitutes
      sku_ids = candidate_bom_items.collect {|cbi| cbi.subcomponent_id}
      cases_in_inventory = CurrentInventoryLevel.sku_quantity(self.site, sku_ids, :unit_of_measure => Sku::CASES)
      fg_units_remaining = self.units_required
      current_position = 0

      while fg_units_remaining > 0 and current_position < candidate_bom_items.size
        current_candidate = candidate_bom_items[current_position]
        candidate_cases_in_inventory = cases_in_inventory[current_candidate.subcomponent_id]
        fg_units_remaining = request_subcomponent(user.item_cart, current_candidate, candidate_cases_in_inventory, fg_units_remaining)
        current_position += 1
      end

      if fg_units_remaining > 0
        cases_required = fg_units_remaining * bom_item.quantity_in(Sku::CASES)
        add_required_item user.item_cart, bom_item.subcomponent, cases_required
      end
    end

    true
  end

  def request_subcomponent item_cart, bom_item, cases_in_inventory, fg_units_remaining
    subcomponent = bom_item.subcomponent
    cases_recipe = bom_item.quantity_in(Sku::CASES)
    cases_in_inventory = 0 if cases_in_inventory < 0
    fg_units_produceable = (cases_in_inventory.to_f / cases_recipe).floor
    fg_units_to_produce = [fg_units_produceable, fg_units_remaining].min
    subcomponent_cases_required = fg_units_to_produce * cases_recipe

    if subcomponent_cases_required > 0
      add_required_item item_cart, subcomponent, subcomponent_cases_required
    end

    fg_units_remaining - fg_units_to_produce
  end

  def units_scheduled
    past? ?  self.units_produced : [self.units_produced, self.units_expected].max
  end

  def past?
    self.scheduled_end_at < Time.zone.now
  end

  def seed
    duration = 0
    self.units_expected = 0

    duration = self.project.units_unscheduled / self.project.sku.units_per_hour if self.project.sku and self.project.sku.units_per_hour > 0
    duration = [default_shift_length, duration].min
    duration = [0.25, duration].max
    duration = 8 if self.project.long_running?
    self.scheduled_end_at = self.scheduled_start_at + duration.hours
    self.calculate_units_expected
  end

  def invoiced?
    !!self.invoice_item_id
  end

  def self.not_invoiced
    find(:all, :conditions => ["invoice_item_id is NULL"])
  end

  def sku
    self.project.try(:sku)
  end

  def bom_items
    return [] unless sku
    sku.bom_items
  end

  def all_bom_items
    sku.try(:all_bom_items) || []
  end

  def sku_id
    self.sku.try(:id)
  end

  def item_category_name
    self.sku.try(:item_category).try(:name)
  end

  def item_type_name
    self.sku.try(:item_type).try(:name)
  end

  def unpaid_breaks
    self.breaks.collect {|b| b if !b.paid}.compact
  end

  def total_revenue
    expected_financial :total_charge
  end

  def total_revenue_per_unit
    expected_financial_per_unit :total_charge
  end

  def labor_revenue
    expected_financial :labour_charge
  end

  def labor_revenue_per_unit
    expected_financial_per_unit :labour_charge
  end

  def expected_labor_expense
    expected_financial :labour_cost
  end

  def expected_labor_expense_per_unit
    expected_financial_per_unit :labour_cost
  end

  def materials_revenue
    expected_financial :materials_charge
  end

  def materials_revenue_per_unit
    expected_financial_per_unit :materials_charge
  end

  def expected_materials_expense
    expected_financial :materials_cost
  end

  def expected_materials_expense_per_unit
    expected_financial_per_unit :materials_cost
  end

  def overhead_revenue
    expected_financial :overhead_charge
  end

  def overhead_revenue_per_unit
    expected_financial_per_unit :overhead_charge
  end

  def expected_overhead_expense
    expected_financial :overhead_cost
  end

  def expected_overhead_expense_per_unit
    expected_financial_per_unit :overhead_cost
  end

  def expected_total_expense
    expected_overhead_expense + expected_materials_expense + expected_labor_expense
  end

  def expected_total_expense_per_unit
    expected_overhead_expense_per_unit + expected_materials_expense_per_unit + expected_labor_expense_per_unit
  end

  def expected_profit
    total_revenue - expected_total_expense
  end

  def expected_profit_per_unit
    total_revenue_per_unit - expected_total_expense_per_unit
  end

  def expected_margin
    total_revenue_per_unit == 0 ? 0 : expected_profit_per_unit / total_revenue_per_unit
  end

  def actual_people
    self.time_reports.current_personnel_count
  end

  def actual_labor_expense
    self.time_reports.map { |t| t.badge_type.machine? ? 0 : t.labor_expense }.sum
  end

  def actual_labor_expense_per_unit
    units_produced == 0 ? 0 : actual_labor_expense / units_produced
  end

  def actual_materials_expense_from_productions
    self.productions.map {|p| p.materials_expense}.sum
  end

  def actual_materials_expense_from_rejected_items
    self.rejected_items.map {|r| r.materials_expense}.sum
  end

  def actual_materials_expense
    actual_materials_expense_from_productions + actual_materials_expense_from_rejected_items
  end

  def actual_overhead_expense
    return 0 if self.started_at.nil?
    overhead_item = project.site.overhead_item_for self.started_at
    return 0 if overhead_item.nil?
    total_person_hours = Job.total_person_hours(self.project.site, self.started_at)

    expense_per_man_hour = overhead_item.daily_total.to_f / total_person_hours
    expense_per_man_hour * self.person_hours
  end

  def person_hours
    self.time_reports.map { |t| t.duration(:hours) }.sum
  end

  def productive_person_hours(options={})
    self.time_reports.map { |t| t.job = self; t.badge_type.machine? ? 0 : t.productive_hours(options) }.sum
  end

  def person_hours_per_unit
    self.units_produced == 0 ? 0 : self.productive_person_hours / self.units_produced
  end

  def self.total_person_hours(site, day)
    site.jobs.find(:all).map do |j|
      if j.started_at and j.started_at.beginning_of_day == day.beginning_of_day
        j.person_hours
      else
        0
      end
    end.sum
  end

  def actual_overhead_expense_per_unit
    units_produced == 0 ? 0: actual_overhead_expense / units_produced
  end

  def actual_materials_expense_per_unit
    units_produced == 0 ? 0 : actual_materials_expense / units_produced
  end

  def difference_materials_expense
    expected_materials_expense - actual_materials_expense
  end

  def difference_materials_expense_per_unit
    expected_materials_expense_per_unit - actual_materials_expense_per_unit
  end

  def difference_labor_expense
    expected_labor_expense - actual_labor_expense
  end

  def difference_labor_expense_per_unit
    expected_labor_expense_per_unit - actual_labor_expense_per_unit
  end

  def difference_overhead_expense
    expected_overhead_expense - actual_overhead_expense
  end

  def difference_overhead_expense_per_unit
    expected_overhead_expense_per_unit - actual_overhead_expense_per_unit
  end

  def actual_total_expense
    actual_labor_expense + actual_materials_expense + actual_overhead_expense
  end

  def actual_total_expense_per_unit
    actual_labor_expense_per_unit + actual_materials_expense_per_unit + actual_overhead_expense_per_unit
  end

  def difference_total_expense
    expected_total_expense - actual_total_expense
  end

  def difference_total_expense_per_unit
    expected_total_expense_per_unit - actual_total_expense_per_unit
  end

  def actual_profit
    total_revenue - actual_total_expense
  end

  def actual_profit_per_unit
    total_revenue_per_unit - actual_total_expense_per_unit
  end

  def difference_profit
    expected_profit - actual_profit
  end

  def difference_profit_per_unit
    expected_profit_per_unit - actual_profit_per_unit
  end

  def actual_margin
    total_revenue == 0 ? 0 : actual_profit / total_revenue
  end

  def difference_margin
    total_revenue == 0 ? 0 : difference_profit / total_revenue
  end

  def predicted_profit
    total_revenue - (actual_labor_expense + actual_materials_expense + expected_overhead_expense)
  end

  def predicted_margin
    total_revenue == 0 ? 0 : predicted_profit / total_revenue
  end

  def charge_per_unit
    expected_financial_per_unit(:total_charge)
  end

  def line_name
    self.line ? self.line.location.name : ''
  end

  def customer_name
    self.project.customer.name
  end

  def sku_customer
    return nil unless sku
    sku.customer
  end

  def customer
    self.project.customer
  end

  def project_code
    self.project.code
  end

  def project_reference_1
    self.project.reference_1
  end

  def project_reference_2
    self.project.reference_2
  end

  def item_description
    self.project.item_description
  end

  def item_code
    self.project.sku_code
  end

  def job_status
    self.status
  end

  def invoiced_status
    invoiced? ? "Invoiced" : "Not Invoiced"
  end

  def project_status
    Project::STATUSES.key(project.status)
  end

  alias_attribute :actual_start_at, :started_at
  alias_attribute :actual_end_at, :ended_at

  def line_leader_name
    accepted_by ? accepted_by.login : ''
  end

  def predefined_lot_code default=nil
    return nil unless self.project.sku
    return nil unless self.project.sku.track_lot_code?

    if self.project.use_lot_code?
      self.project.lot_code
    else
      default ? default : last("lot_code", self.project.sku)
    end
  end

  def predefined_expiry_date default=nil
    return nil unless self.project.sku
    return nil unless self.project.sku.track_expiry_date?

    if self.project.use_expiry_date?
      self.project.expiry_date
    else
      default ? default : last("expiry_date", self.project.sku)
    end
  end

  def last(property, sku)
    return '' if productions.empty?
    last_production = productions.paging.first
    if self.project.sku && self.project.sku == sku
      return last_production.send(property)
    else
      last_production.subcomponent_consumptions.each do |s|
        return s.send(property) if s.sku == sku
      end
    end
    ''
  end

  def self.ended_last_end_at
    results = find(:first, :include => [:time_reports], :order => "time_reports.ended_at DESC", :conditions => "time_reports.ended_at is not null")
    results.nil? ? nil : results.time_reports[0].ended_at
  end

 def create_invoice_items( invoice )
    return nil if self.invoice_item
    if self.time_reports.empty?
      invoice.errors.add(:base, "Job #{self.id} cannot be added because it does not have any time reports.")
      return nil
    end

    invoice_items = []
    sku = self.project.sku
    uom = sku ? sku.unit_of_measure : ""
    notes = sku ? sku.description : ""
    unit_rate = self.charge_per_unit

    quantity = self.units_produced
    invoice_item = invoice.invoice_items.create( :sku => sku, :quantity => quantity, :unit_of_measure => uom, :notes => notes, :unit_rate => unit_rate )
    self.update_attribute :invoice_item_id, invoice_item.id
    invoice_items << invoice_item
    invoice_items
  end

  def production_start
    self.productions.minimum(:produced_at)
  end

  # This method should be saving the reject!!!
  def add_reject subcomponent, lot_code, expiry_date, quantity, options = {}
    options = options.merge(validate_lot_and_expiry: site.setting_require_lot_expiry_for_track_by_job_rejects)
    RejectedItems::CreateRejectService.create(self, subcomponent, lot_code, expiry_date, quantity, options)
  end

  def expected_person_hours_to_date(options={})
    self.sku ? self.sku.assembly_procedure.personnel * duration(options) : 0
  end

  def expected_units_given_actual_personnel(options={})
    return 0 if self.expected_person_hours_to_date(options) == 0
    self.sku ? fraction_of_expected_people(options) * expected_units_given_actual_hours(options) : 0
  end

  def self.scheduled_between site, sku, start_time, end_time
    site.jobs.find(:all,
      :conditions => [":start_time < scheduled_end_at AND :end_time > scheduled_start_at AND :sku_id = skus.id",
        {:start_time => start_time, :end_time => end_time, :sku_id => sku.id}],
      :include => [:project => [:sku]])
  end

  def expected_units_between interval_start_at, interval_end_at
    calculated_start = [scheduled_start_at, interval_start_at].max
    calculated_end = [scheduled_end_at, interval_end_at].min
    number_of_hours = ((calculated_end - calculated_start).to_f / 60 / 60)

    self.units_expected_per_hour * number_of_hours
  end

  def self.all_expected_units_between site, sku, interval_start, interval_end
    jobs = self.scheduled_between site, sku, interval_start, interval_end
    jobs.map {|j| j.expected_units_between(interval_start, interval_end) }.sum
  end

  def reseed_time_reports
    self.time_reports.each do |tr|
      tr.seed_cost_per_hour
      tr.save
    end
  end

  def reseed_productions
    self.productions.each do |pr|
      pr.update_cost_per_unit
      pr.skip_update_inventory_adjustment = true
      pr.save
    end
  end

  def reseed_rejected_items
    self.rejected_items.each do |ri|
      ri.seed_cost_per_unit
      ri.save
    end
  end

  def scenario_charge
    (self.project and self.project.scenario) ? self.project.scenario.effective_scenario_charge(self.started_at) : nil
  end

  def eligible_users
    users = self.accepted_by ? [self.accepted_by] : []
    users.concat(self.project.site.active_users.regular_users).uniq
  end

  def has_active_data?
    return false if self.time_reports.count(:conditions => "ended_at IS NULL") == 0 and self.breaks.count(:conditions => "ended_at IS NULL") == 0
    true
  end

  def are_productions_within_duration?
    start_time = self.started_at
    end_time = self.ended_at
    production_start_time = production_start_at
    production_end_time = production_end_at

    if production_start_time.nil?
      return true
    elsif start_time.nil?
      return false
    elsif end_time.nil?
      return production_start_time >= start_time
    else
      production_start_time >= start_time and production_end_time <= end_time
    end
  end

  # This method should only be used to create NEW consumption plans
  # That is to say, don't use this if you have an existing consumption plan data that the user has modified!
  # This method should get refactored into methods on the consumption plan
  def consumption_plan substitutions=[]
    ces = if self.sku
      self.sku.bom_items.tracked.map do |bi|
        ConsumptionEntry.new :subcomponent => bi.subcomponent, :consume => true, :bom_item => bi
      end
    else
      []
    end
    plan = ConsumptionPlan.new :consumption_entries => ces
    plan.substitutions = substitutions
    plan.consumption_entries.each do |ce|
      ce.lot_code = last("lot_code", ce.subcomponent)
      ce.expiry_date = last("expiry_date", ce.subcomponent)
    end
    plan
  end

  def closed?
    !self.ended_at.nil?
  end

  def has_production?
    self.eaches_produced > 0
  end

  def accept_line_materials
    return {:status => NO_SKU_FOR_JOB} if self.sku.nil?
    return {:status => NOT_USING_JOB_WIP_PALLET} if !self.site.use_job_wip_pallet?
    return {:status => JOB_HAS_RECONCILED_SUBCOMPONENTS} if self.has_reconciled_subcomponents?

    skus = self.sku.all_bom_items.reject{|bi| bi.subcomponent.quick_consume?}.map(&:subcomponent)
    return {:status => NO_SUBCOMPONENTS_FOUND} if skus.empty?

    ias = LineInventoryRepository.find_unassigned_inventory(self.line, skus)
    reserved_ias = LineInventoryRepository.find_assigned_inventory(self.project, self.line, skus)
    ias.concat(reserved_ias)

    return {:status => NO_INVENTORY_FOUND, :line => self.line} if ias.empty?

    expected_unit_moves = []
    ias.each do |ia|
      expected_unit_moves << ExpectedUnitMove.new(:sku => ia.sku, :from_pallet => ia.pallet, :from_location => ia.location, :to_location => self.line.location,
        :unit_quantity => ia.each_quantity, :unit_of_measure => Sku::EACHES, :lot_code => ia.lot_code, :expiry_date => ia.expiry_date,
        :reserved_project_id => ia.reserved_project_id, :site_id => self.site_id)
    end

    error_array = nil
    transaction do
      move = self.site.moves.create! :job => self, :status => Move::CLOSED, :notes => Utils::I18n.in_account_locale{s_("MOVE_GENERATED_NOTES_MSG|System generated move to accept materials to job.")}
      move.move_units expected_unit_moves
      Jobs::JobLotExpiriesAdjuster.update(move.job)

      error_array = move.errors.full_messages
      raise ActiveRecord::Rollback if move.has_errors?
    end

    if error_array.empty?
      return {:status => ACCEPT_MATERIALS_SUCCESS, :line => self.line}
    else
      return {:status => MOVE_ERROR_ON_MOVE, :message => error_array.join("\n")}
    end
  end


  # if these constants change, remember to also change addReconciliationStatusThreshold in reports.js
  NOT_RECONCILED = 0
  DO_NOT_RECONCILE = 1
  RECONCILED = 2
  RECONCILIATION_IN_PROGRESS = 3

  scope :with_production, :conditions => ["eaches_produced > 0"]
  scope :not_reconciled, :conditions => ["reconciliation_status = #{NOT_RECONCILED}"]
  scope :with_reconciliation_status_in, lambda {|statuses| {:conditions => {:reconciliation_status => statuses}}}
  scope :with_reconciliation, :conditions => ["job_reconciliation_id IS NOT NULL"]
  scope :on_reconciliation, lambda {|jr| {:conditions => {:job_reconciliation_id => jr.id}}}
  scope :with_reconciled_subcomponents,
    :joins => <<-SQL
      INNER JOIN job_reconciliations AS jr ON jr.id = jobs.job_reconciliation_id
      INNER JOIN job_reconciliation_records AS jrr ON jrr.job_reconciliation_id = jr.id
    SQL
  scope :on_line, lambda {|line| {:conditions => {:line_id => line.id}}}
  scope :stopped, :conditions => ["status = '#{STOPPED}'"]

  def find_or_create_job_reconciliation
    if self.job_reconciliation
      return self.job_reconciliation
    else
      return join_existing_or_create_job_reconciliation
    end
  end

  def join_existing_or_create_job_reconciliation
    existing_reconciliation = existing_reconciliation_for_project_and_line
    if existing_reconciliation
      existing_reconciliation.toggle_job self.id
      return existing_reconciliation
    else
      return self.site.job_reconciliations.create :jobs => [self]
    end
  end

  def existing_reconciliation_for_project_and_line
    jobs_with_reconciliation = self.project.jobs.on_line(self.line).with_reconciliation
    return if jobs_with_reconciliation.empty?
    jobs_with_reconciliation.all.map(&:job_reconciliation).detect {|jr| jr.can_change_job_selection?}
  end

  def has_reconciliation?
    self.reconciliation_status == RECONCILIATION_IN_PROGRESS || self.reconciliation_status == RECONCILED
  end

  def do_not_reconcile
    self.reconciliation_status == DO_NOT_RECONCILE
  end
  alias do_not_reconcile? do_not_reconcile

  def do_not_reconcile=(arg)
    @do_not_reconcile = ActiveRecord::ConnectionAdapters::Column.value_to_boolean arg
  end

  def set_do_not_reconcile
    return if @do_not_reconcile.nil?
    self.reconciliation_status = (@do_not_reconcile ? DO_NOT_RECONCILE : NOT_RECONCILED)
  end

  def validate_do_not_reconcile
    if (self.reconciliation_status_changed?)
      if changing_reconciliation_status_to_not_reconciled
        self.errors.add(:do_not_reconcile, s_("DoNotReconcile|cannot be set if there is a Reconciliation for this Job."))
      end
      if self.reconciliation_status != DO_NOT_RECONCILE && bom_items.empty?
        self.errors.add(:do_not_reconcile, s_("DoNotReconcile|cannot be set if there are no subcomponents for this Job."))
      end
    end
  end

  def time_remaining
    return 0 unless self.sku
    projected_units_per_hour = self.sku.units_per_person_hour * actual_people
    return 0 if projected_units_per_hour == 0
    return 0 if units_produced > units_expected
    (units_expected - units_produced) / projected_units_per_hour
  end

private
  def changing_reconciliation_status_to_not_reconciled
    (self.reconciliation_status_was == RECONCILIATION_IN_PROGRESS || self.reconciliation_status_was == RECONCILED) &&
    (self.reconciliation_status == DO_NOT_RECONCILE || self.reconciliation_status == NOT_RECONCILED)
  end

public
  def has_reconciled_subcomponents?
    self.project.jobs.with_reconciled_subcomponents.include?(self)
  end

  def set_schedule_to_default_shift
    now = Time.zone.now
    start_time = self.site.default_shift.start_at
    self.scheduled_start_at = Time.zone.local(now.year, now.month, now.day, start_time.hour, start_time.min)

    end_time = self.site.default_shift.end_at
    self.scheduled_end_at = Time.zone.local(now.year, now.month, now.day, end_time.hour, end_time.min)
  end

  # TODO: Unify with Sku#inventory_count, since they both should support similar options
  def query_wip_quantity sku, lot_code, expiry_date, project_id=nil
    options = {:lot_code => lot_code, :expiry_date => expiry_date, :reserved_project_id => project_id, :unit_of_measure => :eaches}

    if sku.track_lot_code_by == Sku::TRACK_BY_JOB && self.site.include_track_by_job_subs_in_missing_inventory
      options.delete(:lot_code)
      options.delete(:expiry_date)
    end

    qty = CurrentInventoryLevel.get_quantity self.site, sku, self.line.location_id, self.get_wip_pallet, options
    qty || 0.0
  end

  def insert_consumable_moves required_unit_moves
    move = self.site.moves.create! :notes => Utils::I18n.in_account_locale{s_('MOVE_GENERATED_NOTES_MSG|System generated move to support consumables')},
                                   :status => Move::CLOSED,
                                   :site => self.site
    unit_moves = Moves::UnitMoveCreator.bulk_new move, required_unit_moves
    move_from_ias = []
    move_to_ias = []

    unit_moves.each do |um|
      move_from_ias << um.from_inventory_adjustment
      move_to_ias << um.to_inventory_adjustment
    end

    status = InventoryAdjustment.bulk_insert move_from_ias, :validate => self.site.validate_quick_consume
    unless status.failed_instances.empty?
      self.errors.add(:base, s_("JOB_SHOW_ADD_PRODUCTION_ERROR_MSG|Quick consume encountered conflicts, please try again"))
      raise ActiveRecord::Rollback
    end
    InventoryAdjustment.bulk_insert move_to_ias

    UnitMove.bulk_insert unit_moves
    UnitMove.notify_observers(:units_moved, unit_moves)
  end

  def update_pallets_produced
    self.update_attribute :pallets_produced, Production.count(
      'pallets.id',
      distinct: true,
      joins: "INNER JOIN pallets ON productions.pallet_id = pallets.id AND pallets.job_id = productions.job_id",
      conditions: {job_id: self.id})
  end

private
  def expected_units_given_actual_hours(options)
    self.sku.assembly_procedure.units_per_hour * self.duration(options)
  end

  def fraction_of_expected_people(options={})
    self.productive_person_hours(options) / self.expected_person_hours_to_date(options)
  end

  def expected_financial(value)
    self.units_produced * expected_financial_per_unit(value)
  end

  def expected_financial_per_unit(value)
    return 0 if self.project.scenario.nil?
    return self.scenario_charge.send((value.to_s + "_per_unit").to_sym) if self.sku.nil?
    value_per_scenario_unit = self.scenario_charge.send((value.to_s + "_per_unit").to_sym)
    value_per_scenario_unit * self.sku.uom_multiplier( self.project.scenario.unit_of_measure )
  end

  def add_required_item item_cart, subcomponent, subcomponent_cases_required
    item_cart.seed(self.line.location, [subcomponent]) do |sub|
      params = {:sku => sub, :quantity => subcomponent_cases_required, :unit_of_measure => Sku::CASES}
      if sub.account.reserve_inventory_for_projects? && sub.reserve_for_projects?
        params.merge!({:reserved_project_id => project.id})
      end
      params
    end
  end

  def self.job_schedule_query_conditions(user)
    conditions = "scheduled_start_at < :to and scheduled_end_at > :from"
    conditions << " AND projects.customer_id = :customer_id" if user.customer?
    conditions
  end

  def handle_quantity_errors quantity, units, options
    if quantity.to_d <= 0
      self.errors.add("quantity", s_("JOB_SHOW_ADD_PRODUCTION_QUANTITY|must be a valid number"))
      return
    end

    sku.bom_items.each do |bi|
      self.errors.add("base", SubcomponentConsumption.quantity_too_small_error_message(bi.subcomponent)) if bi.quantity*quantity.to_d < 0.00001
    end

    self.errors.add("quantity", s_("JOB_SHOW_ADD_PRODUCTION_QUANTITY|must be greater than 0.00001")) if self.sku.convert(quantity, units, :eaches) < 0.00001
    self.errors.add("quantity", s_("JOB_SHOW_ADD_PRODUCTION_QUANTITY|must be less than 30 pallets when converted")) if self.sku.convert(quantity, units, :pallets).ceil > 30 && !options[:pallet_ids]
  end

  # TODO: handle non-consumed and substitute
  def handle_lot_expiry_errors lot_code, expiry_date
    self.errors.add self.sku.code, s_("JOB_SHOW_LOT_CODE|must have lot code entered.") if sku.track_lot_code? and lot_code.blank?
    self.errors.add self.sku.code, s_("JOB_SHOW_EXPIRY_DATE|must have expiry date entered.") if sku.track_expiry_date? and expiry_date.blank?
    self.errors.add self.sku.code, s_("JOB_SHOW_EXPIRY_DATE|must have an expiry date in the format of {{{expiry_date_format}}}").i(:expiry_date_format => self.sku.expiry_date_format.user_format_guide) if !sku.valid_expiry_date_format?(expiry_date)
  end

  def top_up_pallet pallet, quantity_in_eaches, lot_code, expiry_date, consumption_plan, new_productions
    quantity_on_pallet = [self.project.sku.units_per_full_pallet(:eaches) - pallet.eaches, quantity_in_eaches].min
    new_productions << pallet.create_production(self, quantity_on_pallet, consumption_plan, lot_code, expiry_date) if quantity_on_pallet > 0
    quantity_on_pallet
  end

  def expiry_date_is_blank? expiry_date
    expiry_date.nil? || expiry_date == ""
  end


  def lot_code_is_blank? lot_code
    lot_code == nil || lot_code == ""
  end

  def calculate_units_produced(options={})
    return 0 unless project and project.sku

    where_clause = ["job_id = :job_id"]
    where_params = {:job_id => self.id}

    if options[:end]
      where_clause << "produced_at < :produced_end"
      where_params[:produced_end] = options[:end]
    end

    if options[:start]
      where_clause << "produced_at >= :produced_start"
      where_params[:produced_start] = options[:start]
    end

    conditions = [where_clause.join(" AND "), where_params]
    eaches = Production.sum('each_quantity', :conditions => conditions)
    eaches ? project.sku.convert(eaches, :eaches) : 0
  end

  def self.with_pick_plan pick_plan
    where(:pick_plan_id => pick_plan.id).first
  end

end
